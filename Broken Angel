local Global = (getgenv and getgenv()) or shared
if game:GetService("Players").LocalPlayer.Character.Name ~= "GelatekReanimate" then
	error("Not Reanimated")
end
if game:FindFirstChildOfClass("TestService"):FindFirstChild("ScriptCheck") then
	error("Script Running")
end
local getsynasset = getsynasset or getcustomasset or function() warn("no getcustomasset/getsynasset") end
local Events = Global.TableOfEvents
Global.AntiScript()
Global.GetLoadLibrary()

local Player = game.Players.LocalPlayer

-- Created by Nebula_Zorua --
-- The Broken Angel --

warn([[
	-> THE BROKEN ANGEL <-
		Ahahah... Ahahahahah..
		You thought that you'd end me THAT easily!?
		Foolish mortals! Now struggle!
	
]])

wait(1/60)

--// Shortcut Variables \\--
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players

--// Initializing \\--
local Plr = Plrs.LocalPlayer
local Char = Plr.Character
local Hum = Char:FindFirstChildOfClass'Humanoid'
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Root = Char:FindFirstChild'HumanoidRootPart'
local Torso = Char.Torso
local Head = Char.Head
local NeutralAnims = true
local Attack = false
local Debounces = {Debounces={}}
local Mouse = Plr:GetMouse()
local Hit = {}
local Sine = 0
local Change = 1
local BloodPuddles = {}
local Introed = false
local DoneIntroed = false
local Effects = IN("Folder",Char)
Effects.Name = "Effects"


--// Debounce System \\--


function Debounces:New(name,cooldown)
	local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
	setmetatable(aaaaa,{__index = Debounces})
	Debounces.Debounces[name] = aaaaa
	return aaaaa
end

function Debounces:Use(overrideUsable)
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.Usable or overrideUsable)then
		self.Usable = false
		self.CoolingDown = true
		local LastUse = time()
		self.LastUse = LastUse
		delay(self.Cooldown or 2,function()
			if(self.LastUse == LastUse)then
				self.CoolingDown = false
				self.Usable = true
			end
		end)
	end
end

function Debounces:Get(name)
	assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
	for i,v in next, Debounces.Debounces do
		if(i == name)then
			return v;
		end
	end
end

function Debounces:GetProgressPercentage()
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.CoolingDown and not self.Usable)then
		return math.max(
			math.floor(
				(
					(time()-self.LastUse)/self.Cooldown or 2
				)*100
			)
		)
	else
		return 100
	end
end

--// Instance Creation Functions \\--
local baseSound = IN("Sound")
local Decal = IN("Decal")
function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or Torso
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Char
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function Clone(instance,parent,properties)
	local inst = instance:Clone()
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound
end

--// Customization \\--

local Frame_Speed = 60 -- The frame speed for swait. 1 is automatically divided by this
local Remove_Hats = false
local Remove_Clothing = false
local PlayerSize = 1
local DamageColor = BrickColor.new'Really red'
local MusicID = 456406906
local God = false
local Muted = false

local WalkSpeed = 0

--// Weapon and GUI creation \\--

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local Music = Sound(Char,MusicID,1,3,true,false,true)
Music.Name = 'Music'

--// Stop animations \\--
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end

pcall(game.Destroy,Char:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')

--// Joints \\--

local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5 * PlayerSize,0)})
local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})
local HW = NewInstance('Motor',Char,{Part0=Head,Part1=HaloHandle,C0=CF.N(0,2,0)}) 
local WW = NewInstance('Motor',Char,{Part0=Torso,Part1=WingHandle,C0=CF.N(0,1.5,1.5)}) 

local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0

--// Artificial HB \\--

local ArtificialHB = IN("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/Frame_Speed
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end


--// Effect Function(s) \\--

function NoobySphere(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,MeshId,Axis)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	local Scale = 1
	local speeder = Speed
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do

			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			speeder = speeder - 0.01*Speed*Lifetime
			fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
			fxP.Transparency = fxP.Transparency + 0.01*Lifetime
			if(Axis == 'x')then
				fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, 0, 0)
			elseif(Axis == 'y')then
				fxM.Scale = fxM.Scale + Vector3.new(0, Scale*Lifetime, 0)
			elseif(Axis == 'z')then
				fxM.Scale = fxM.Scale + Vector3.new(0, 0, Scale*Lifetime)
			elseif(Axis == 'xyz')then
				fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime,Scale*Lifetime,Scale*Lifetime)
			elseif(Axis == 'yz')then
				fxM.Scale = fxM.Scale + Vector3.new(0,Scale*Lifetime,Scale*Lifetime)
			elseif(Axis == 'xz')then
				fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime,0,Scale*Lifetime)
			else
				fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, 0)
			end
			if(fxP.Transparency >= 1)then break end
			swait()
		end
		fxP:destroy()
	end)()
	return fxP
end

function NoobySphere2(Lifetime,Type,Pos,StartSize,Inc,Color,MeshId)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())

	local Scale = 1
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do

			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			fxP.Transparency = fxP.Transparency + 0.01*Lifetime
			fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
			swait()
		end
		fxP:destroy()
	end)()
end

function NoobyBlock(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,Fade,MeshId)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Brick),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	local Scale = 1
	local speeder = Speed
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			if(Fade)then
				fxP.Transparency = i/(10/Lifetime)
			end
			speeder = speeder - 0.01*Speed*Lifetime/10
			fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
			fxM.Scale = fxM.Scale - Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
			swait()
		end
		fxP:destroy()
	end)()
end

function Bezier(startpos, pos2, pos3, endpos, t)
	local A = startpos:lerp(pos2, t)
	local B  = pos2:lerp(pos3, t)
	local C = pos3:lerp(endpos, t)
	local lerp1 = A:lerp(B, t)
	local lerp2 = B:lerp(C, t)
	local cubic = lerp1:lerp(lerp2, t)
	return cubic
end

function Puddle(hit,pos,norm,data)
	local material = data.Material or Enum.Material.SmoothPlastic
	local color = data.Color or BrickColor.new'Crimson'
	local size = data.Size or 1

	if(hit.Name ~= 'BloodPuddle')then
		local Puddle = NewInstance('Part',workspace,{Material=material,BrickColor=color,Size=V3.N(size,.1,size),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
		local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
		BloodPuddles[Puddle] = 0
	else
		local cyl = hit:FindFirstChild'CylinderMesh'
		if(cyl)then
			BloodPuddles[hit] = 0
			cyl.Scale = cyl.Scale + V3.N(size,0,size)
			hit.Transparency = 0
		end
	end
end

function Droplet(data)
	--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
	local Size = data.Size or 1
	local Color = data.Color or BrickColor.new'Crimson'
	local StudsPerFrame = data.Speed or 1
	local Shape = data.Shape or 'Ball'
	local Frames = (data.Frames or 160)+1
	local Pos = data.Origin or Root.CFrame
	local Direction = data.Direction or Root.CFrame.lookVector*100000
	local Material = data.Material or Enum.Material.SmoothPlastic
	local Drop = data.Drop or .05
	local Ignorelist = data.Ignorelist or nil

	local Bullet = Part(Effects,Color,Material,V3.N(Size,Size,Size),Pos,true,false)
	local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
	if(Shape == 'Ball')then
		BMesh.MeshType = Enum.MeshType.Sphere
	elseif(Shape == 'Head')then
		BMesh.MeshType = Enum.MeshType.Head
	elseif(Shape == 'Cylinder')then
		BMesh.MeshType = Enum.MeshType.Cylinder
	end

	coroutine.wrap(function()
		for i = 1, Frames do
			Pos = Pos * CF.N(0,-(Drop*i),0)
			local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i)).p,StudsPerFrame)
			if(hit and (not hit.Parent or not hit.Parent:FindFirstChildOfClass'Humanoid' and not hit.Parent:IsA'Accessory'))then
				Puddle(hit,pos,norm,data)
				break;
			else
				Bullet.CFrame = CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i))
			end
			swait()
		end
		Bullet:destroy()
	end)()
end

function SphereFX(duration,color,scale,pos,endScale,increment)
	return Effect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		Mesh={MeshType=Enum.MeshType.Sphere},
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function BlastFX(duration,color,scale,pos,endScale,increment)
	return Effect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		Mesh={MeshType=Enum.MeshType.FileMesh,MeshId='rbxassetid://20329976'},
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function BlockFX(duration,color,scale,pos,endScale,increment)
	return Effect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function ShootBullet(data)
	--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
	local Size = data.Size or V3.N(2,2,2)
	local Color = data.Color or BrickColor.new'Crimson'
	local StudsPerFrame = data.Speed or 10
	local Shape = data.Shape or 'Ball'
	local Frames = data.Frames or 160
	local Pos = data.Origin or Torso.CFrame
	local Direction = data.Direction or Mouse.Hit
	local Material = data.Material or Enum.Material.Neon
	local OnHit = data.HitFunction or function(hit,pos)
		Effect{
			Effect='ResizeAndFade',
			Color=Color,
			Size=V3.N(10,10,10),
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.05,.05,.05),
				EndIsIncrement=true
			}
		}
		for i = 1, 5 do
			local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			Effect{
				Effect='Fade',
				Frames=65,
				Size=V3.N(5,5,10),
				CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-10).p,pos),
				Mesh = {MeshType=Enum.MeshType.Sphere},
				Material=Enum.Material.Neon,
				Color=Color,
				MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
			}	
		end
	end	

	local Bullet = Part(Effects,Color,Material,Size,Pos,true,false)
	local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
	if(Shape == 'Ball')then
		BMesh.MeshType = Enum.MeshType.Sphere
	elseif(Shape == 'Head')then
		BMesh.MeshType = Enum.MeshType.Head
	elseif(Shape == 'Cylinder')then
		BMesh.MeshType = Enum.MeshType.Cylinder
	end

	coroutine.wrap(function()
		for i = 1, Frames+1 do
			local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame)
			if(hit)then
				OnHit(hit,pos,norm,dist)
				break;
			else
				Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
			end
			swait()
		end
		Bullet:destroy()
	end)()

end


function Zap(data)
	local sCF,eCF = data.StartCFrame,data.EndCFrame
	assert(sCF,"You need a start CFrame!")
	assert(eCF,"You need an end CFrame!")
	local parts = data.PartCount or 15
	local zapRot = data.ZapRotation or {-5,5}
	local startThick = data.StartSize or 3;
	local endThick = data.EndSize or startThick/2;
	local color = data.Color or BrickColor.new'Electric blue'
	local delay = data.Delay or 35
	local delayInc = data.DelayInc or 0
	local lastLightning;
	local MagZ = (sCF.p - eCF.p).magnitude
	local thick = startThick
	local inc = (startThick/parts)-(endThick/parts)

	for i = 1, parts do
		local pos = sCF.p
		if(lastLightning)then
			pos = lastLightning.CFrame*CF.N(0,0,MagZ/parts/2).p
		end
		delay = delay + delayInc
		local zapPart = Part(Effects,color,Enum.Material.Neon,V3.N(thick,thick,MagZ/parts),CF.N(pos),true,false)
		local posie = CF.N(pos,eCF.p)*CF.N(0,0,MagZ/parts).p+V3.N(M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)))
		if(parts == i)then
			local MagZ = (pos-eCF.p).magnitude
			zapPart.Size = V3.N(endThick,endThick,MagZ)
			zapPart.CFrame = CF.N(pos, eCF.p)*CF.N(0,0,-MagZ/2)
			Effect{Effect='ResizeAndFade',Size=V3.N(thick,thick,thick),CFrame=eCF*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),Color=color,Frames=delay*2,FXSettings={EndSize=V3.N(thick*8,thick*8,thick*8)}}
		else
			zapPart.CFrame = CF.N(pos,posie)*CF.N(0,0,MagZ/parts/2)
		end

		lastLightning = zapPart
		Effect{Effect='Fade',Manual=zapPart,Frames=delay}

		thick=thick-inc

	end
end

function Zap2(data)
	local Color = data.Color or BrickColor.new'Electric blue'
	local StartPos = data.Start or Torso.Position
	local EndPos = data.End or Mouse.Hit.p
	local SegLength = data.SegL or 2
	local Thicc = data.Thickness or 0.5
	local Fades = data.Fade or 45
	local Parent = data.Parent or Effects
	local MaxD = data.MaxDist or 200
	local Branch = data.Branches or false
	local Material = data.Material or Enum.Material.Neon
	local Raycasts = data.Raycasts or false
	local Offset = data.Offset or {0,360}
	local AddMesh = (data.Mesh == nil and true or data.Mesh)
	if((StartPos-EndPos).magnitude > MaxD)then
		EndPos = CF.N(StartPos,EndPos)*CF.N(0,0,-MaxD).p
	end
	local hit,pos,norm,dist=nil,EndPos,nil,(StartPos-EndPos).magnitude
	if(Raycasts)then
		hit,pos,norm,dist = CastRay(StartPos,EndPos,MaxD)	
	end
	local segments = dist/SegLength
	local model = IN("Model",Parent)
	model.Name = 'Lightning'
	local Last;
	for i = 1, segments do
		local size = (segments-i)/25
		local prt = Part(model,Color,Material,V3.N(Thicc+size,SegLength,Thicc+size),CF.N(),true,false)
		if(AddMesh)then IN("CylinderMesh",prt) end
		if(Last and math.floor(segments) == i)then
			local MagZ = (Last.CFrame*CF.N(0,-SegLength/2,0).p-EndPos).magnitude
			prt.Size = V3.N(Thicc+size,MagZ,Thicc+size)
			prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,EndPos)*CF.A(M.R(90),0,0)*CF.N(0,-MagZ/2,0)	
		elseif(not Last)then
			prt.CFrame = CF.N(StartPos,pos)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)	
		else
			prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,CF.N(pos)*CF.A(M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360)))*CF.N(0,0,SegLength/3+(segments-i)).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
		end
		Last = prt
		if(Branch)then
			local choice = M.RNG(1,7+((segments-i)*2))
			if(choice == 1)then
				local LastB;
				for i2 = 1,M.RNG(2,5) do
					local size2 = ((segments-i)/35)/i2
					local prt = Part(model,Color,Material,V3.N(Thicc+size2,SegLength,Thicc+size2),CF.N(),true,false)
					if(AddMesh)then IN("CylinderMesh",prt) end
					if(not LastB)then
						prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,Last.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
					else
						prt.CFrame = CF.N(LastB.CFrame*CF.N(0,-SegLength/2,0).p,LastB.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
					end
					LastB = prt
				end
			end
		end
	end
	if(Fades > 0)then
		coroutine.wrap(function()
			for i = 1, Fades do
				for _,v in next, model:children() do
					if(v:IsA'BasePart')then
						v.Transparency = (i/Fades)
					end
				end
				swait()
			end
			model:destroy()
		end)()
	else
		S.Debris:AddItem(model,.01)
	end
	return {End=(Last and Last.CFrame*CF.N(0,-Last.Size.Y/2,0).p),Last=Last,Model=model}
end

function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)

	tween:Play()
end

function Effect(data)
	local Color = data.Color or C3.N(0,0,0)
	local Material = data.Material or Enum.Material.Neon;
	local MeshD = data.Mesh or {};
	local SoundD = data.Sound or nil;
	local Shape = data.Shape or Enum.PartType.Block;
	local Size = data.StartSize or V3.N(.1,.1,.1);
	local ESize = data.EndSize or V3.N(6,6,6);
	local Direction = data.Direction or nil;
	local Speed = data.Speed or .1; -- studs per second
	local Boomerang = data.Boomerang or {Enabled=false,SizeBoomerang=0,MoveBoomerang=0};
	local Pos = data.CFrame or Torso.CFrame;
	local Frames = data.Frames or 60;
	local RotInc = data.RotInc or {0,0,0}
	local StartTrans = data.TransStart or 0;
	local EndTrans = data.TransEnd or 1;
	local KeepOrientation = data.KeepOrien or false;

	if(typeof(RotInc) == 'number')then RotInc = {RotInc,RotInc,RotInc}; end
	local S,PM,P;

	coroutine.wrap(function()
		P = Part(Effects,Color,Material,V3.N(1,1,1),Pos,true,false)

		if(MeshD == "Blast")then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',Size,V3.N(0,0,-Size.X/8))
		elseif(MeshD == 'Ring')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',Size,V3.N(0,0,0))
		elseif(MeshD == 'Slash1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',V3.N(Size.X/10,.001,Size.Z/10),V3.N(0,0,0))
		elseif(MeshD == 'Slash2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',V3.N(Size.X/1000,Size.Y/100,Size.Z/100),V3.N(0,0,0))
		elseif(MeshD == 'Tornado1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',Size/10,V3.N(0,0,0))
		elseif(MeshD == 'Tornado2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',Size/4,V3.N(0,0,0))
		elseif(MeshD == 'Skull')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',Size*2,V3.N(0,0,0))
		elseif(MeshD == 'Crystal')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',Size,V3.N(0,0,0))
		elseif(MeshD == 'Cloud')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',Size,V3.N(0,0,0))
		elseif(typeof(MeshD) == 'table')then
			local Type = MeshD.Type or Enum.MeshType.Brick
			local ID = MeshD.ID or '';
			local Tex = MeshD.Texture or '';
			local Offset = MeshD.Offset or V3.N(0,0,0)
			PM = Mesh(P,Type,ID,Tex,Size,Offset)
		else
			PM = Mesh(P,Enum.MeshType.Brick,'','',Size)
		end

		if(typeof(SoundD) == 'table' and SoundD.ID and SoundD.ID ~= '')then
			local ID = SoundD.ID or '';
			local Pitch = SoundD.Pitch or 1;
			local Volume = SoundD.Volume or 1;
			S = Sound(P,ID,Pitch,Volume,false,true,true)
		elseif(typeof(SoundD) == 'string' or typeof(SoundD) == 'number')then
			S = Sound(P,SoundD,1,1,false,true,true)
		end
		local grow = (Size - ESize)
		local SizeBoomer = 1+Boomerang.SizeBoomerang/50
		local MoveBoomer = 1+Boomerang.MoveBoomerang/50
		if(Boomerang and Boomerang.Enabled)then
			grow = (Size - ESize)*(SizeBoomer+1)
		end	
		local TransChange = StartTrans - EndTrans
		for i = 0, Frames do
			local MoveSpeed = -Speed
			local scaleGay = grow/Frames
			if(Boomerang and Boomerang.Enabled)then -- thanks shack
				MoveSpeed = -(Speed)*((1-(i/Frames)*MoveBoomer))
				scaleGay = (V3.N((grow.X)*((1 - (i/Frames)*SizeBoomer)),(grow.Y)*((1 - (i/Frames)*SizeBoomer)),(grow.Z)*((1 - (i/Frames)*SizeBoomer)))*SizeBoomer)/Frames
			end
			PM.Scale = PM.Scale - scaleGay
			if(PM.MeshId == 'rbxassetid://20329976')then
				PM.Offset = V3.N(0,0,-PM.Scale.Z/8)
			elseif(PM.MeshId == 'rbxassetid://4770583')then
				scaleGay = scaleGay*2
			elseif(PM.MeshId == 'rbxassetid://168892432')then
				scaleGay = scaleGay/4
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				scaleGay = scaleGay/10
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				scaleGay = scaleGay/10
			end
			P.Transparency = P.Transparency - TransChange/Frames
			if(RotInc == 'random')then
				P.CFrame=P.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			elseif(typeof(RotInc) == 'table')then
				P.CFrame=P.CFrame*CF.A(unpack(RotInc))
			end


			if(Direction and Speed)then
				local Orientation = P.Orientation
				P.CFrame = CF.N(P.Position,P.Position+Direction)*CF.N(0,0,MoveSpeed)
				if(KeepOrientation)then P.Orientation = Orientation end
			end
			swait()
		end

		P.Transparency = 1
		if(S and S.Playing)then
			repeat swait() until not S.Parent or not S.Playing
		end
		if(S and S.Parent)then
			S:destroy()
		end
		P:destroy()
	end)()


end

function SoulSteal(whom)
	local torso = (whom:FindFirstChild'Head' or whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso' or whom:FindFirstChild'LowerTorso' or whom:FindFirstChild'HumanoidRootPart')
	print(torso)
	if(torso and torso:IsA'BasePart')then
		local Model = Instance.new("Model",Effects)
		Model.Name = whom.Name.."'s Soul"
		whom:BreakJoints()
		local Soul = Part(Model,BrickColor.new'Really red','Glass',V3.N(.5,.5,.5),torso.CFrame,true,false)
		Soul.Name = 'Head'
		NewInstance("Humanoid",Model,{Health=0,MaxHealth=0})
		Effect{
			Effect="Arc",
			Manual = Soul,
			FXSettings={
				Start=torso.CFrame,
				Home = Torso,
				RemoveOnGoal = true,
			}
		}
		local lastPoint = Soul.CFrame.p

		for i = 0, 1, 0.01 do 
			local point = CFrame.new(lastPoint, Soul.Position) * CFrame.Angles(-math.pi/2, 0, 0)
			local mag = (lastPoint - Soul.Position).magnitude
			Effect{
				Effect = "Fade",
				CFrame = point * CF.N(0, mag/2, 0),
				Size = V3.N(.5,mag+.5,.5),
				Color = Soul.BrickColor
			}
			lastPoint = Soul.CFrame.p
			swait()
		end
		for i = 1, 5 do
			Effect{
				Effect="Fade",
				Color = BrickColor.new'Really red',
				MoveDirection = (Torso.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
			}	
		end
	end
end

--// Other Functions \\ --

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function getRegion(point,range,ignore)
	return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

function clerp(startCF,endCF,alpha)
	return startCF:lerp(endCF, alpha)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end


function ShowDamage(Pos, Text, Time, Color)
	coroutine.wrap(function()
		local Rate = Frame_Speed
		local Pos = (Pos or Vector3.new(0, 0, 0))
		local Text = (Text or "")
		local Time = (Time or 2)
		local Color = (Color or Color3.new(1, 0, 1))
		local EffectPart = NewInstance("Part",Effects,{
			Material=Enum.Material.SmoothPlastic,
			Reflectance = 0,
			Transparency = 1,
			BrickColor = BrickColor.new(Color),
			Name = "Effect",
			Size = Vector3.new(0,0,0),
			Anchored = true,
			CFrame = CF.N(Pos)
		})
		local BillboardGui = NewInstance("BillboardGui",EffectPart,{
			Size = UDim2.new(2.5, 0, 2.5, 0),
			Adornee = EffectPart,
		})
		local TextLabel = NewInstance("TextLabel",BillboardGui,{
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			Font = "Bodoni",
			TextColor3 = Color,
			TextStrokeColor3 = Color3.new(0,0,0),
			TextStrokeTransparency=0,
			TextScaled = true,
			Rotation=M.RNG(-30,30),
		})
		EffectPart.Parent = workspace
		delay(0, function()
			local Frames = (Time * Rate)
			swait((Time*Frame_Speed)/2)
			for Frame = 1, Frames do
				swait()
				local Percent = (Frame / Frames)
				TextLabel.TextTransparency = Percent
				TextLabel.TextStrokeTransparency = Percent
				BillboardGui.Size = UDim2.new(2.5-(Percent*2),0,2.5-(Percent*2),0)
			end

			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end) end)()
end

function Kill(whom,hum)
	local stop = script:FindFirstChild'StopRetaliating' and script:FindFirstChild'StopRetaliating':Clone();
	if(stop and S.Players:GetPlayerFromCharacter(whom))then
		stop.Disabled = false
		stop.Parent = whom
	end
	pcall(function()
		for _,v in next, whom:children() do
			if(v:IsA'BasePart')then
				v:breakJoints()
				v.Parent = Effects
				v:ClearAllChildren()
				Sound(v,338594556,.6,1,false,true,true)
				v.CanCollide = false
				v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
				v.Anchored = false
				local dustT = NewInstance("ParticleEmitter",v,{
					Color = ColorSequence.new(C3.N(.2,.2,.2)),
					LightEmission=0,
					LightInfluence=1,
					Size=NumberSequence.new(1,0),
					Texture="rbxassetid://284205403",
					Transparency=NumberSequence.new{NumberSequenceKeypoint.new(0,.2,0),NumberSequenceKeypoint.new(.6,.8,0),NumberSequenceKeypoint.new(1,1,0)},
					Lifetime = NumberRange.new(.25,3),
					Rate=250,
					Acceleration=V3.N(0,0,0),
					Speed = NumberRange.new(0),
					Enabled = true
				})
				v.Color = C3.N(.2,.2,.2)
				v.Material = Enum.Material.Neon
				local bv = NewInstance('BodyPosition',v,{MaxForce=V3.N(150,150,150),P=2500,position=v.Position+V3.N(M.RNG(-15,15),M.RNG(-15,15),M.RNG(-15,15))})
				v.Transparency = .25
				coroutine.wrap(function()
					for i = v.Transparency, 1, .01 do
						v.Transparency = i
						swait(1)
					end
					v.Transparency = 1
					dustT.Enabled = false
					S.Debris:AddItem(v,3)
				end)()
			end
		end
	end)
end

function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 

	local DB = data.Debounce or .2;

	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;

	local DamageEffects = data.DamageFX or {}
	local DamageType = DamageEffects.Type or "Normal"
	local DeathFunction = DamageEffects.DeathFunction

	assert(Who,"Specify someone to damage!")	

	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local DoneDamage = M.RNG(MinDam,MaxDam) * (M.RNG(1,100) <= CritChance and CritMultiplier or 1)

	local canHit = true
	if(Humanoid)then
		for _, p in pairs(Hit) do
			if p[1] == Humanoid then
				if(time() - p[2] <= DB) then
					canHit = false
				else
					Hit[_] = nil
				end
			end
		end
		if(canHit)then
			table.insert(Hit,{Humanoid,time()})
			local player = S.Players:GetPlayerFromCharacter(Who)
			if(not player or Plr.UserId == 5719877 or player.UserId ~= 5719877 and player.UserId ~= 19081129)then
				if(Who:FindFirstChild'Head' and Humanoid.Health > 0)then
					ShowDamage((Who.Head.CFrame * CF.N(0, 0, (Who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "DEATH", .5, C3.N(.2,.2,.2))
					Kill(Who)
				end
			end
		end
	end		
end

function AOEDamage(where,range,options)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent])then
			local callTable = {Who=v.Parent}
			hit[v.Parent] = true
			for _,v in next, options do callTable[_] = v end
			DealDamage(callTable)
		end
	end
	return hit
end

function AOEHeal(where,range,amount)
	local healed = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
		if(hum and not healed[hum])then
			hum.Health = hum.Health + amount
			if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
				ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
			end
		end
	end	
end

function Corpse(who) -- TODO: Ragdoll
	local Corpse = IN("Model",workspace)
	Corpse.Name = "Corpse"
	for _,v in next, who:children() do
		if(not v:IsA'Tool' and not v:IsA'BaseScript' and not v:IsA'Accessory')then
			local gay = v
			if(gay:IsA'Humanoid')then
				gay.PlatformStand = true
				gay.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
			end
			gay.Parent = Corpse
		else
			v:destroy()
		end
	end	
	return Corpse
end

function FindNearestTorso(pos,mag)
	local tors,dist,hum;
	for _,v in next, workspace:children() do
		if(v ~= Char and GetTorso(v) and (GetTorso(v).Position-pos).magnitude < (dist or mag or math.huge) and v:FindFirstChildOfClass'Humanoid')then
			tors = GetTorso(v)
			dist = (GetTorso(v).Position-pos).magnitude
			hum = v:FindFirstChildOfClass'Humanoid'
		end
	end
	return tors,dist,hum
end

function FireMeteorScatter(start,scatter,size,speed)
	local pos = CF.N(start*CF.A(0,M.RRNG(0,360),M.RRNG(0,360))*CF.N(0,0,-scatter).p)
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(size*2,.05,size*2),start,true,false)

	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	coroutine.wrap(function()
		for i = 0, .5, .02 do
			circle.CFrame = circle.CFrame:lerp(pos,i);
			swait()
		end
		for i = size*2, .05, -.2 do
			circle.Size = V3.N(i,.05,i)
			swait()
		end
		circle:destroy()
		SoundPart(331888777,1,5,false,true,true,pos)
		for y = 100, 1, -(speed or 2) do
			Effect{
				Mesh={Type=Enum.MeshType.Sphere},
				Frames=30,
				Color=C3.N(.1,.1,.1),
				CFrame=pos*CF.N(0,y,0),
				StartSize=V3.N(size*2,size*2,size*2),
				EndSize=V3.N(.05,.05,.05),
				--RotInc='random',
			}
			swait()
		end
		AOEDamage(pos.p,size*8,{})
		SoundPart(206049428,1,3,false,true,true,pos)
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=60,
			Color=C3.N(.1,.1,.1),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*8,size*8),
			--RotInc='random',
		}
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=30,
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*16,size*16,size*16),
			--RotInc='random',
		}
		Effect{
			Frames=30,
			Mesh='Tornado2',
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*8,size*8),
			RotInc={0,M.RNG(-50,50)/100,0},
			--RotInc='random',
		}
		Effect{
			Frames=30,
			Mesh='Blast',
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*16,.05,size*16),
			RotInc={0,.25,0},
		}
		Effect{
			Frames=30,
			Mesh='Blast',
			Color=C3.N(.6,.6,.6),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*20,.05,size*20),
			RotInc={0,-.25,0},
		}
	end)()
end	

function FireMeteor(pos,size,speed)
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(size*2,.05,size*2),pos,true,false)
	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	coroutine.wrap(function()
		for i = size*2, .05, -.1 do
			circle.Size = V3.N(i,.05,i)
			swait()
		end
		circle:destroy()
		SoundPart(331888777,1,5,false,true,true,pos)
		for y = 100, 1, -(speed or 2) do
			Effect{
				Mesh={Type=Enum.MeshType.Sphere},
				Frames=30,
				Color=C3.N(.1,.1,.1),
				CFrame=pos*CF.N(0,y,0),
				StartSize=V3.N(size*2,size*2,size*2),
				EndSize=V3.N(.05,.05,.05),
				--RotInc='random',
			}
			swait()
		end
		SoundPart(206049428,.9,6,false,true,true,pos)
		AOEDamage(pos.p,size*8,{})
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=60,
			Color=C3.N(.1,.1,.1),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*8,size*8),
			--RotInc='random',
		}
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=30,
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*16,size*16,size*16),
			--RotInc='random',
		}
		Effect{
			Frames=30,
			Mesh='Tornado2',
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*8,size*8),
			RotInc={0,M.RNG(-50,50)/100,0},
		}
		Effect{
			Frames=30,
			Mesh='Blast',
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*24,.05,size*24),
			RotInc={0,.25,0},
		}
		Effect{
			Frames=30,
			Mesh='Blast',
			Color=C3.N(.6,.6,.6),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*28,.05,size*28),
			RotInc={0,-.25,0},
		}
	end)()
end

function ScatterLaserNigger(start,scatter,size,speed)
	local pos = CF.N(start*CF.A(0,M.RRNG(0,360),M.RRNG(0,360))*CF.N(0,0,-scatter).p)
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(size*2,.05,size*2),start,true,false)

	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	coroutine.wrap(function()
		for i = 0, .5, .02 do
			circle.CFrame = circle.CFrame:lerp(pos,i);
			swait()
		end
		for i = size*2, .05, -.2 do
			circle.Size = V3.N(i,.05,i)
			swait()
		end
		circle:destroy()
		for y = 100, 1, -(speed or 2) do
			Effect{
				Mesh={Type=Enum.MeshType.Sphere},
				Frames=30,
				Color=C3.N(.1,.1,.1),
				CFrame=pos*CF.N(0,y,0),
				StartSize=V3.N(size*2,size*2,size*2),
				EndSize=V3.N(.05,.05,.05),
				--RotInc='random',
			}
			swait()
		end
		AOEDamage(pos.p,size*8,{})
		SoundPart(206049428,1,3,false,true,true,pos)
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=60,
			Color=C3.N(.1,.1,.1),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*8,size*8),
			--RotInc='random',
		}
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=30,
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*16,size*16,size*16),
			--RotInc='random',
		}
		Effect{
			Frames=30,
			Mesh='Tornado2',
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*8,size*8),
			RotInc={0,M.RNG(-50,50)/100,0},
			--RotInc='random',
		}
		Effect{
			Frames=30,
			Mesh='Blast',
			Color=C3.N(0,0,0),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*16,.05,size*16),
			RotInc={0,.25,0},
		}
		Effect{
			Frames=30,
			Mesh='Blast',
			Color=C3.N(.6,.6,.6),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*20,.05,size*20),
			RotInc={0,-.25,0},
		}
	end)()
end	


function LaserNigger(pos,size,speed)
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(size*2,.05,size*2),pos,true,false)
	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	coroutine.wrap(function()
		for i = size*2, .05, -(speed or .01) do
			circle.Size = V3.N(i,.05,i)
			swait()
		end
		circle:destroy()
		SoundPart(919941001,1.3,10,false,true,true,pos)
		AOEDamage(pos.p,size*4,{})
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=60,
			Color=C3.N(.1,.1,.1),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*32,size*8),
			--RotInc='random',
		}
	end)()
end

function SilentLaserNigger(pos,size,speed)
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(size*2,.05,size*2),pos,true,false)
	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	coroutine.wrap(function()
		for i = size*2, .05, -(speed or .01) do
			circle.Size = V3.N(i,.05,i)
			swait()
		end
		circle:destroy()
		AOEDamage(pos.p,size*4,{})
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=60,
			Color=C3.N(.1,.1,.1),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*32,size*8),
			--RotInc='random',
		}
	end)()
end


function ScatterLaserNigger(start,scatter,size,speed)
	local pos = CF.N(start*CF.A(0,M.RRNG(0,360),M.RRNG(0,360))*CF.N(0,0,-scatter).p)
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(size*2,.05,size*2),start,true,false)

	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	coroutine.wrap(function()
		for i = 0, .5, .02 do
			circle.CFrame = circle.CFrame:lerp(pos,i);
			swait()
		end
		for i = size*2, .05, -(speed or .01) do
			circle.Size = V3.N(i,.05,i)
			swait()
		end
		circle:destroy()
		SoundPart(919941001,1.3,10,false,true,true,pos)
		AOEDamage(pos.p,size*4,{})
		Effect{
			Mesh={Type=Enum.MeshType.Sphere},
			Frames=60,
			Color=C3.N(.1,.1,.1),
			CFrame=pos,
			StartSize=V3.N(.1,.1,.1),
			EndSize=V3.N(size*8,size*32,size*8),
			--RotInc='random',
		}
	end)()
end	


function Intro()
	Introed = true
	Attack = true
	NeutralAnims = false
	WalkSpeed = 0
	local homoGay = {}
	for _,v in next, Wings:children() do
		if(v:IsA'BasePart')then
			homoGay[v] = v.Transparency
			v.Transparency = 1
		end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart')then
			homoGay[v] = v.Transparency
			v.Transparency = 1
		end
	end
	if(Plr.UserId ~= 5719877 and Plr.UserId ~= 52302680)then
		repeat swait() 
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CFrame.new(0, -0.659279823, -0.288724184, 1, 0, 0, 0, 0.906307876, 0.422617942, 0, -0.422617942, 0.906307876),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.456918478, -0.507697642, -0.944418013, 0.986825883, 0.161786035, -5.37728511e-06, -0.1516985, 0.92530781, 0.347552806, 0.056234166, -0.342973292, 0.937660456),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.477304339, -0.125261724, -0.507861257, 0.98992312, -0.141605809, -3.82855831e-07, 0.127958953, 0.894523203, -0.428316146, 0.0606523976, 0.423999995, 0.903628945),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.62397927, 0.737813473, -0.324518442, 0.906307757, -0.4226183, -5.19416233e-07, -0.365998745, -0.784886122, -0.499998629, 0.211308151, 0.453152895, -0.866026163),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(0.697078168, 0.665875912, -0.34805128, 0.906307697, 0.383022696, -0.17860584, 0.242404759, -0.817320883, -0.522710621, -0.346188307, 0.430441678, -0.833590746),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(8.61270819e-05, 1.49900413, -0.00497497618, 0.999878228, 0.000897826976, -0.0155868568, -2.24914402e-07, 0.998345912, 0.0574918389, 0.0156126935, -0.0574848056, 0.998224258),Alpha)

		until Music.TimePosition >= 2
		local laugh = Sound(Head,415880409,1,5,false,false,true)
		repeat swait() 
			local Alpha = .1
			local gay = 0.5
			RJ.C0 = RJ.C0:lerp(CFrame.new(0, -0.659279823+gay, -0.288724184, 1, 0, 0, 0, 0.906307876, 0.422617942, 0, -0.422617942, 0.906307876),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.456918478, -0.507697642-gay, -0.944418013, 0.986825883, 0.161786035, -5.37728511e-06, -0.1516985, 0.92530781, 0.347552806, 0.056234166, -0.342973292, 0.937660456),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.477304339, -0.125261724-gay, -0.507861257, 0.98992312, -0.141605809, -3.82855831e-07, 0.127958953, 0.894523203, -0.428316146, 0.0606523976, 0.423999995, 0.903628945),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.62397927, 0.737813473, -0.324518442, 0.906307757, -0.4226183, -5.19416233e-07, -0.365998745, -0.784886122, -0.499998629, 0.211308151, 0.453152895, -0.866026163),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(0.697078168, 0.665875912, -0.34805128, 0.906307697, 0.383022696, -0.17860584, 0.242404759, -0.817320883, -0.522710621, -0.346188307, 0.430441678, -0.833590746),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(8.61270819e-05, 1.49900413, -0.00497497618, 0.999878228, 0.000897826976, -0.0155868568, -2.24914402e-07, 0.998345912, 0.0574918389, 0.0156126935, -0.0574848056, 0.998224258),Alpha)
		until Music.TimePosition >= 4
		laugh:Pause()
		repeat swait() 
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CFrame.new(0, -0.659279823, -0.288724184, 1, 0, 0, 0, 0.906307876, 0.422617942, 0, -0.422617942, 0.906307876),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.456918478, -0.507697642, -0.944418013, 0.986825883, 0.161786035, -5.37728511e-06, -0.1516985, 0.92530781, 0.347552806, 0.056234166, -0.342973292, 0.937660456),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.477304339, -0.125261724, -0.507861257, 0.98992312, -0.141605809, -3.82855831e-07, 0.127958953, 0.894523203, -0.428316146, 0.0606523976, 0.423999995, 0.903628945),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.62397927, 0.737813473, -0.324518442, 0.906307757, -0.4226183, -5.19416233e-07, -0.365998745, -0.784886122, -0.499998629, 0.211308151, 0.453152895, -0.866026163),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(0.697078168, 0.665875912, -0.34805128, 0.906307697, 0.383022696, -0.17860584, 0.242404759, -0.817320883, -0.522710621, -0.346188307, 0.430441678, -0.833590746),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(8.61270819e-05, 1.49900413, -0.00497497618, 0.999878228, 0.000897826976, -0.0155868568, -2.24914402e-07, 0.998345912, 0.0574918389, 0.0156126935, -0.0574848056, 0.998224258),Alpha)
		until Music.TimePosition >= 6
		laugh.TimePosition = 4
		laugh:Resume()
		repeat swait() 
			local Alpha = .1
			local gay = 0.5
			RJ.C0 = RJ.C0:lerp(CFrame.new(0, -0.659279823+gay, -0.288724184, 1, 0, 0, 0, 0.906307876, 0.422617942, 0, -0.422617942, 0.906307876),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.456918478, -0.507697642-gay, -0.944418013, 0.986825883, 0.161786035, -5.37728511e-06, -0.1516985, 0.92530781, 0.347552806, 0.056234166, -0.342973292, 0.937660456),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.477304339, -0.125261724-gay, -0.507861257, 0.98992312, -0.141605809, -3.82855831e-07, 0.127958953, 0.894523203, -0.428316146, 0.0606523976, 0.423999995, 0.903628945),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.62397927, 0.737813473, -0.324518442, 0.906307757, -0.4226183, -5.19416233e-07, -0.365998745, -0.784886122, -0.499998629, 0.211308151, 0.453152895, -0.866026163),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(0.697078168, 0.665875912, -0.34805128, 0.906307697, 0.383022696, -0.17860584, 0.242404759, -0.817320883, -0.522710621, -0.346188307, 0.430441678, -0.833590746),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(8.61270819e-05, 1.49900413, -0.00497497618, 0.999878228, 0.000897826976, -0.0155868568, -2.24914402e-07, 0.998345912, 0.0574918389, 0.0156126935, -0.0574848056, 0.998224258),Alpha)
		until laugh.TimePosition >= 8
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CFrame.new(0, -0.925739288, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.496666431, -0.249598682, -0.898787975, 1, 0, 0, 0, 0.93765074, 0.347578913, 0, -0.347578913, 0.93765074),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.4983325, -0.246445477, -0.88995266, 1, 0, 0, 0, 0.93765074, 0.347578913, 0, -0.347578913, 0.93765074),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.876811266, 0.333975524, -0.106851757, 0.906307876, -0.422618061, 5.81481174e-07, -0.36599797, -0.78488642, -0.499998838, 0.211308971, 0.453152657, -0.866026103),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(0.856369436, 0.279425353, -0.014354825, 0.906307876, 0.422618061, -5.81481174e-07, 0.36599797, -0.78488642, -0.499998838, -0.211308971, 0.453152657, -0.866026103),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(8.58334824e-05, 1.49900258, -0.00497419387, 0.999878109, 0.000897928199, -0.0155862626, -3.57576369e-07, 0.998346031, 0.0574919991, 0.0156121058, -0.0574849918, 0.998224318),Alpha)
		end
		local homo = 0
		repeat swait()
			local Alpha = .1
			homo = homo + .01
			Effect{
				Frames=15,
				Color=C3.N(0,0,0),
				CFrame=Root.CFrame*CF.N(M.RNG(-15,15),-3,M.RNG(-15,15)),
				Mesh={Type='Sphere'},
				StartSize=V3.N(.5,.5,.5),
				EndSize=V3.N(.5,25,.5),
			}
			local gay =0.5
			RJ.C0 = RJ.C0:lerp(CFrame.new(0, -0.626411915+homo+gay, 0.0182328075, 1, 0, 0, 0, 0.903630018, -0.428314, 0, 0.428314, 0.903629959),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.496665955, -0.249583066, -0.898805976, 1, 0, 0, 0, 0.93765074, 0.347579092, 0, -0.347579092, 0.937650681),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.498333931, -0.246427357, -0.889974713, 1, 0, 0, 0, 0.93765074, 0.347579092, 0, -0.347579092, 0.937650681),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.53490865, 0.416545421, 0.18082881, 0.87681073, 0.480835706, 0, -0.126874655, 0.231357872, 0.96456027, 0.463795006, -0.845736742, 0.263862848)*CF.N(0,gay,0),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.44881904, 0.437981188, 0.0229511559, 0.876781881, -0.480888277, -1.65002821e-05, 0.126891181, 0.231321871, 0.964566827, -0.463845015, -0.845716715, 0.263839245)*CF.N(0,gay,0),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(8.62274319e-05, 1.49898553, -0.00497042388, 0.999878228, 0.000896761485, -0.0155832022, 6.03031367e-07, 0.998346269, 0.05749017, 0.015608984, -0.0574831665, 0.998224556),Alpha)

		until Music.TimePosition >= 16.1
		Effect{
			Frames=45,
			Color=C3.N(0,0,0),
			CFrame=Torso.CFrame,
			Mesh={Type='Sphere'},
			StartSize=V3.N(.5,.5,.5),
			EndSize=V3.N(15,15,15),
		}
		Effect{
			Frames=45,
			Color=C3.N(0,0,0),
			CFrame=Torso.CFrame,
			Mesh={Type='Sphere'},
			StartSize=V3.N(1,1,1),
			EndSize=V3.N(30,30,30),
		}
		laugh:Destroy()
	end
	Instance.ClearChildrenOfClass(Char,"Decal",true)
	Instance.ClearChildrenOfClass(Char,"Clothing",true)

	for _,v in next, Char:children() do
		if(v:IsA'Accessory' and v:FindFirstChild'Handle')then
			v.Handle.Color = C3.N(0,0,0)
			pcall(function() v.Handle.Mesh.TextureId = "" end)
		elseif(v:IsA'Shirt' or v:IsA'Pants')then
			v:destroy()
		elseif(v:IsA'CharacterMesh')then
			v:destroy()
		elseif(v:FindFirstChildOfClass'ShirtGraphic')then
			v:FindFirstChildOfClass'ShirtGraphic':destroy()
		end
		if v:FindFirstChildOfClass("SpecialMesh") then
			v:FindFirstChildOfClass("SpecialMesh").TextureId = ""
		end
	end
	for _,v in next, Wings:children() do
		if(homoGay[v])then
			v.Transparency = homoGay[v]
		end
	end
	for _,v in next, Halo:children() do
		if(homoGay[v])then
			v.Transparency = homoGay[v]
		end
	end
	Music.TimePosition = 16.1
	DoneIntroed = true
	Attack = false
	NeutralAnims = true
	WalkSpeed = 42
end

function Taunt()
	local taunt = IN("Sound",Head)
	taunt.Volume = 4
	taunt.Pitch = 1.1
	taunt.SoundId = 'rbxassetid://149337769'
	taunt:Play();
	WalkSpeed = 0
	Attack = true
	NeutralAnims = false
	while taunt.Playing and taunt.Parent do
		swait()
		local hell = 0.5
		local Alpha = .1
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12)+hell,0)*CF.A(M.R(0+5*M.S(Sine/12)),0,0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,0+.1*M.C(Sine/12),-.5)*CF.A(0,M.R(10+8*M.C(Sine/12)),M.R(90+8*M.C(Sine/12))),Alpha)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.1*M.C(Sine/12),-.5)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(-90-8*M.C(Sine/12))),Alpha)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4-hell,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-hell,0)*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
	end
	WalkSpeed = 42
	taunt:destroy()
	Attack = false
	NeutralAnims = true
end

function YoPlait()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, .1 do
		swait()
		local Alpha = .1
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),0,0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(10+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function GrabDahPussy()
	Attack = true
	NeutralAnims = false
	WalkSpeed = 0
	for i = 0, 3, .1 do
		swait()
		local Alpha = .1
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(25),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(-30),0,M.R(-60)),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
	end
	local tor,dis,hum;
	local weld,grabbed;
	for i = 0, 1.5, .1 do
		swait()
		local Alpha = .3
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(-25),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),-.3)*CF.A(M.R(60),0,M.R(30)),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		if(not grabbed)then
			tor,dis,hum = FindNearestTorso(LArm.CFrame.p)
			if(dis and dis < 4)then
				WalkSpeed = 0
				Hum.JumpPower = 0
				grabbed = tor.Parent
				if(grabbed:FindFirstChild'HumanoidRootPart')then
					grabbed.HumanoidRootPart:destroy()
				end
				weld = Weld(LArm,tor,CF.N(0,-2.5,-.5)*CF.A(M.R(90),0,M.R(180)))
				break
			end	
		end
	end
	if(grabbed)then
		for i = 0, 3, .1 do
			swait()
			local Alpha = .1
			Change = 1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(-25),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),-.3)*CF.A(M.R(60),0,M.R(30)),.2)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			Effect{
				Frames=30,
				StartSize=V3.N(.25,.25,.25),
				EndSize=V3.N(2,2,2),
				CFrame=tor.CFrame*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360)),
				Color=C3.N(.1,.1,.1),
				RotInc={M.RNG(-50,50)/100,M.RNG(-50,50)/100,M.RNG(-50,50)/100},
			}
		end
		repeat 
			hum.Health = hum.Health-Hum.MaxHealth/100
			Effect{
				Frames=30,
				StartSize=V3.N(.25,.25,.25),
				EndSize=V3.N(2,2,2),
				Mesh='Tornado2',
				CFrame=tor.CFrame,
				Color=C3.N(.1,.1,.1),
				RotInc={0,M.RNG(-50,50)/100,0},
			}
			Sound(tor,693432581,.7,5,false,true,true)
			local Alpha = .1
			Change = 1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(-25),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),-.3)*CF.A(M.R(60),0,M.R(30)),.2)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			swait()
		until hum.Health <= Hum.MaxHealth/10 or hum.MaxHealth >= 1e40
		ShowDamage(tor.Position+V3.N(M.RRNG(-5,5),2.5,M.RNG(-5,5)),'DEATH',1,C3.N(.2,.2,.2))
		local corpse = Corpse(grabbed)
		local clicc = false
		local gay;
		gay = Mouse.Button1Down:connect(function()
			gay:disconnect()
			clicc = true
		end)
		repeat swait()
			Root.CFrame = CF.N(Root.Position,V3.N(Mouse.Hit.x,Root.Position.y,Mouse.Hit.z))
			local Alpha = .1
			Change = 1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(0),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(180),0,0),.2)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		until clicc
		weld:destroy()
		local bv = IN("BodyVelocity") 
		bv.maxForce = V3.N(1e9, 1e9, 1e9)
		bv.velocity = CF.N(tor.Position,Mouse.Hit.p).lookVector*150
		bv.Parent = tor
		bv.Name = "MOVE"
		S.Debris:AddItem(bv,.2)
		for i = 0, 2, .1 do
			local Alpha = .1
			Change = 1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(-15),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(65),0,0),.2)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			swait()
		end
		Kill(corpse)
	end
	Attack = false
	NeutralAnims = true
	WalkSpeed = 42
end

function Niggercus()
	Attack = true
	NeutralAnims = false
	WalkSpeed = 0
	Hum.AutoRotate = false
	local clicc = false
	local gay;
	gay = Mouse.Button1Down:connect(function()
		gay:disconnect()
		clicc = true
	end)
	local where = Mouse.Hit
	repeat swait()
		where = Mouse.Hit
		Root.CFrame = CF.N(Root.Position,V3.N(where.x,Root.Position.y,where.z))
		local Alpha = .1
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(0),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(90),0,0),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(90),0,0),.2)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
	until clicc
	local ray = Part(Char,C3.N(0,0,0),Enum.Material.Neon,V3.N(1,1,1),CF.N(),true,false)
	local rayM = Mesh(ray,Enum.MeshType.Cylinder)
	for i = 0, 6, .1 do
		where = Mouse.Hit
		Root.CFrame = CF.N(Root.Position,V3.N(where.x,Root.Position.y,where.z))
		local Alpha = .1
		Change = 1
		local hit1 = CastRay(Root.CFrame.p,Root.CFrame*CF.N(0,0,.1).p,.15)
		if(not hit1)then
			Root.CFrame = Root.CFrame*CF.N(0,0,.1)
		end
		local h,p,n,d = CastRay(Torso.CFrame.p,where.p,500)
		ray.CFrame = CF.N(Torso.CFrame*CF.N(0,0,0).p,p)*CF.N(0,0,-d/2)*CF.A(0,M.P/2,0)
		rayM.Scale = V3.N(d,5,5)
		Effect{
			CFrame=CF.N(p),
			Direction=V3.N(M.RNG(-1,1),M.RNG(-1,1),M.RNG(-1,1)),
			Speed=M.RNG(50,125)/100,
			Mesh={Type='Sphere'},
			StartSize=V3.N(2,2,2),
			EndSize=V3.N(2,2,15),
			Boomerang={Enabled=true,MoveBoomerang=50,SizeBoomerang=25},
		}
		LaserNigger(CF.N(p),5,.2)
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(0),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(90),0,0),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(90),0,0),.2)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		swait()
	end
	coroutine.wrap(function()
		for i = 0, 1, .025 do
			ray.Transparency = i
			rayM.Scale = rayM.Scale + V3.N(0,.2,.2)
		end
	end)()
	WalkSpeed = 42
	Hum.AutoRotate = true
	Attack = false
	NeutralAnims = true
end

function Meteor()
	Attack = true
	NeutralAnims = false	
	WalkSpeed = 0
	local clicc = false
	local gay;
	gay = Mouse.Button1Down:connect(function()
		gay:disconnect()
		clicc = true
	end)
	local where = Mouse.Hit
	repeat swait()
		where = Mouse.Hit
		Root.CFrame = CF.N(Root.Position,V3.N(where.x,Root.Position.y,where.z))
		local Alpha = .1
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(0),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(180),0,0),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(180),0,0),.2)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
	until clicc
	for i = 0, 1, .1 do
		local Alpha = .3
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(25+5*M.S(Sine/12)),M.R(0),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(180),0,0),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(180),0,0),.2)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		swait()
	end
	where = where.p
	FireMeteor(CF.N(where),6)
	coroutine.wrap(function()
		for i = 1, 5 do
			FireMeteorScatter(CF.N(where),15,2)		
		end
	end)()
	for i = 0, 1, .1 do
		local Alpha = .3
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(-25+5*M.S(Sine/12)),M.R(0),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(75),0,0),.3)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(75),0,0),.3)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		swait()
	end
	for i = 0, 2, .1 do
		local Alpha = .1
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(-25+5*M.S(Sine/12)),M.R(0),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(75),0,0),.2)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(75),0,0),.2)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		swait()
	end
	Attack = false
	NeutralAnims = true
	WalkSpeed = 42
end

function HomoingBullet()
	Attack = true
	NeutralAnims = false
	for i = 0, 5, .1 do
		Root.CFrame = CF.N(Root.Position,V3.N(Mouse.Hit.x,Root.Position.y,Mouse.Hit.z))
		local Alpha = .15
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(65),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),M.R(-65),0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(10+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(90),0,M.R(65)),Alpha)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		swait()
	end	
	local size = 4
	local circle = Part(Effects,C3.N(0,0,0),Enum.Material.Neon,V3.N(.05,.05,.05),RArm.CFrame*CF.N(0,-2,0),true,false)
	circle.Transparency = 1
	local decF = Decal:Clone()
	decF.Face = Enum.NormalId.Top
	decF.Texture = 'rbxassetid://223123319'
	local decB = Decal:Clone()
	decB.Face = Enum.NormalId.Bottom
	decB.Texture = 'rbxassetid://223123319'

	decF.Parent = circle
	decB.Parent = circle
	local gay = 0
	for i = .05, size*2, .2 do
		gay = gay + 2
		Root.CFrame = CF.N(Root.Position,V3.N(Mouse.Hit.x,Root.Position.y,Mouse.Hit.z))
		local Alpha = .15
		Change = 1
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),M.R(65),0),Alpha)
		NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),M.R(-65),0),Alpha)
		LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(10+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(M.R(90),0,M.R(65)),Alpha)
		LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
		RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		circle.Size = V3.N(i,.05,i)
		circle.CFrame = RArm.CFrame*CF.N(0,-2,0)*CF.A(0,M.R(gay),0)
		swait()
	end
	coroutine.wrap(function()
		local Bullet = Part(Effects,C3.N(0,0,0),Enum.Material.Plastic,V3.N(1,1,1),CF.N(circle.CFrame.p),true,false)
		Mesh(Bullet,Enum.MeshType.Sphere,'','',V3.N(size*2,size*2,size*2))
		local hit,pos,norm,dist
		local StudsPerFrame = 1
		local Direction = Mouse.Hit
		for i = 0, Frame_Speed/2 do
			hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame+2)
			Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
			if(hit)then
				break;
			end

			swait()
		end
		if(not hit)then
			StudsPerFrame = 3
			for i = 0, 5*Frame_Speed do
				Direction = Mouse.Hit
				hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame+2)
				Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
				Effect{
					Frames=15,
					CFrame=CF.N(Bullet.CFrame.p,-Bullet.CFrame.lookVector)*CF.N(M.RNG(-4,4),M.RNG(-4,4),M.RNG(-4,4)),
					Direction=-Bullet.CFrame.lookVector,
					Speed=1,
					Mesh={Type=Enum.MeshType.Sphere},
					StartSize=V3.N(size,size,size),
					EndSize=V3.N(0,0,0),
					Color=C3.N(0,0,0),
				}
				if(hit)then
					break;
				end

				swait()
			end
		end
		Sound(Effects,919941001,.8,10,false,true,true)
		Bullet:destroy()
		AOEDamage(pos,size*16,{})
		Effect{
			Frames=30,
			CFrame=CF.N(pos),
			Mesh={Type=Enum.MeshType.Sphere},
			StartSize=V3.N(size*2,size*2,size*2),
			EndSize=V3.N(size*16,size*16,size*16),
			Color=C3.N(0,0,0),
		}
		Effect{
			Frames=30,
			CFrame=CF.N(pos),
			Mesh={Type=Enum.MeshType.Sphere},
			StartSize=V3.N(size*2,size*2,size*2),
			EndSize=V3.N(size*24,size*24,size*24),
			Boomerang={Enabled=true,SizeBoomerang=15,MoveBoomerang=0},
			Color=C3.N(0,0,0),
		}
		for i = 1, 3 do
			ScatterLaserNigger(CF.N(pos),25,size*4,.3)
		end
	end)()
	coroutine.wrap(function()
		for i = size*2, .05, -.1 do
			circle.Size = V3.N(i,.05,i)
			decF.Transparency = 1-(i/(size*2))
			decB.Transparency = 1-(i/(size*2))
			circle.CFrame = circle.CFrame*CF.A(0,M.R(-15),0)
			swait()
		end
		circle:destroy()
	end)()
	Attack = false
	NeutralAnims = true
end

--// Wrap it all up \\--

S.UserInputService.InputBegan:connect(function(io,gpe)
	if(Attack or gpe)then return end
	if(io.KeyCode == Enum.KeyCode.T)then
		Taunt()
	end
	if(io.KeyCode == Enum.KeyCode.Z)then
		GrabDahPussy()
	end
	if(io.KeyCode == Enum.KeyCode.X)then
		Meteor()
	end
	if(io.KeyCode == Enum.KeyCode.C)then
		Niggercus()
	end
	if(io.KeyCode == Enum.KeyCode.V)then
		HomoingBullet()
	end
end)

coroutine.wrap(function()
	while true do
		if(DoneIntroed)then
			swait(3)
			local pos = Root.CFrame*CF.N(M.RNG(-15,15),-3,M.RNG(-15,15))
			Effect{
				Frames=30,
				Color=C3.N(0,0,0),
				CFrame= pos,
				Mesh={Type='Sphere'},
				StartSize=V3.N(.1,3,.1),
				EndSize=V3.N(1.5,45,1.5),
			}
		else
			swait()
		end
	end
end)()
while true do
	swait()
	Sine = Sine + Change
	if(not Music or not Music.Parent)then
		local tp = (Music and Music.TimePosition)
		Music = Sound(Char,MusicID,1,10,true,false,true)
		Music.Name = 'Music'
		Music.TimePosition = tp
	end
	Music.SoundId = "rbxassetid://9046646008"..MusicID
	Music.Parent = Torso
	Music.Pitch = 0.772
	Music.Volume = (DoneIntroed and 3 or .5)
	Music.MaxDistance = 250
	if(not Muted)then
		Music:Resume()
	else
		Music:Pause()
	end

	if(DoneIntroed)then
		Torso.Color = C3.RGB(0,0,0)
		RArm.Color = C3.RGB(0,0,0)
		LArm.Color = C3.RGB(0,0,0)
		RLeg.Color = C3.RGB(0,0,0)
		LLeg.Color = C3.RGB(0,0,0)
		Head.Color = C3.RGB(0,0,0)

		Head.Material = Enum.Material.Neon
		Torso.Material = Enum.Material.Neon
		RArm.Material = Enum.Material.Neon
		LArm.Material = Enum.Material.Neon
		RLeg.Material = Enum.Material.Neon
		LLeg.Material = Enum.Material.Neon

		if(M.RNG(1,25) == 1)then
			local pos = CF.N(Torso.CFrame.p)*CF.N(0,-2,0)*CF.A(0,M.RRNG(-180,180),0)*CF.N(0,0,M.RNG(-25,-10)).p
			local hitfloor2,posfloor2 = workspace:FindPartOnRay(Ray.new(pos,((CFrame.new(pos,pos - Vector3.new(0,1,0))).lookVector).unit * 100), Char)

			if(hitfloor2)then
				pos = posfloor2
			end

			Zap2{Offset={-45,45},Raycasts=true,Color=BrickColor.new'Really black',Material=Enum.Material.Neon,Start=Torso.CFrame.p,End=pos,Thickness=.5,Fade = 25,Mesh=false}
		end
	end
	if(God)then
		Hum.MaxHealth = 1e100
		Hum.Health = 1e100
		if(not Char:FindFirstChildOfClass'ForceField')then IN("ForceField",Char).Visible = false end
		Hum.Name = M.RNG()*100
	end

	local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)

	local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
	local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or Walking and "Walk" or "Idle")
	if(not Effects or not Effects.Parent)then
		Effects = IN("Model",Char)
		Effects.Name = "Effects"
	end																																																																																																				

	Hum.WalkSpeed = WalkSpeed
	if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
	if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end
	if(not Introed)then
		coroutine.wrap(Intro)()
	end
	if(Introed)then
		HW.C0 = HW.C0:lerp(CF.N(0,2,0)*CF.A(M.R(0+15*M.C(Sine/36)),0,M.R(0+15*M.S(Sine/36)))*CF.N(-M.R(0+15*M.S(Sine/36)),0,M.R(0+15*M.C(Sine/36)))*CF.A(0,M.R(Sine/2),0),.3)
		WW.C0 = WW.C0:lerp(CF.N(0,1.5+.3*M.C(Sine/12),1.5),.1)
		for x = 1, #FeatherWelds[2] do
			if(FeatherWelds[1][x][1])then
				FeatherWelds[1][x][1].C0 = FeatherWelds[1][x][1].C0:lerp(CF.N(-2-.5*M.C(Sine/24),x/4+.1*M.S(Sine/24),0-.4*M.S(Sine/24)),.1)
			end
			for i = 2, #FeatherWelds[1][x] do
				FeatherWelds[1][x][i].C0 = FeatherWelds[1][x][i].C0:lerp(CF.N(.5,.25,0)*CF.A(0,0,M.R(2+8*M.C(Sine/12))),.1)
			end
		end

		for x = 1, #FeatherWelds[2] do
			if(FeatherWelds[2][x][1])then
				FeatherWelds[2][x][1].C0 = FeatherWelds[2][x][1].C0:lerp(CF.N(2+.5*M.C(Sine/24),x/4+.1*M.S(Sine/24),0-.4*M.S(Sine/24)),.1)
			end
			for i = 2, #FeatherWelds[2][x] do
				FeatherWelds[2][x][i].C0 = FeatherWelds[2][x][i].C0:lerp(CF.N(-.5,.25,0)*CF.A(0,0,M.R(2-8*M.C(Sine/12))),.1)
			end
		end
	end

	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .1
			Change = 1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(0+5*M.S(Sine/12)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(10+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(0,M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(0,M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		elseif(State == 'Walk')then
			local Alpha = .1
			Change = 1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1.5-.5*M.C(Sine/12),0)*CF.A(M.R(-45+5*M.S(Sine/12)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(45-5*M.S(Sine/12)),0,0)*CF.A(M.R(0-10*M.S(Sine/12)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(10+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.C(Sine/12),0)*CF.A(0,M.R(-10-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.6)*CF.A(M.R(-20+5*M.S(Sine/12)),M.R(5+8*M.C(Sine/12)),M.R(-10+8*M.C(Sine/12))),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-25+5*M.S(Sine/12)),M.R(-5-8*M.C(Sine/12)),M.R(10-8*M.C(Sine/12))),Alpha)
		elseif(State == 'Paralyzed')then
			-- paralyzed
		elseif(State == 'Sit')then
			-- sit
		end
	end

	for i,v in next, BloodPuddles do
		local mesh = i:FindFirstChild'CylinderMesh'
		BloodPuddles[i] = v + 1
		if(not mesh or i.Transparency >= 1)then
			i:destroy() 
			BloodPuddles[i] = nil
		elseif(v >= Frame_Speed*4)then
			local trans = (v-Frame_Speed*4)/(Frame_Speed*2)
			i.Transparency = trans
			if(mesh.Scale.Z > 0)then
				mesh.Scale = mesh.Scale-V3.N(.05,0,.05)
			end
		else
			i.Transparency = 0
		end
	end
end
